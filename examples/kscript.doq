;; kscript.doq - Documentation for kscript
;;
;; @author: Cade Brown <cade@kscript.org>

@set project, kscript manual v0.0.1
@set copyright, {2020 ChemicalDevelopment}


@node kscript manual, {}, {

Welcome to the kscript manual, available online at {@url https://manual.kscript.org, manual.kscript.org}. This document was compiled on {@today}

kscript is a dynamic programming language with expressive syntax, cross-platform support, and a rich standard library. kscript was designed to be a tool useful in many different circumstances – as a computer calculator, as a task-automation language, GUI development language, numerical programming, and more.


@dict
    {What is kscript?}, {{@url https://kscript.org, kscript} is a dynamic programming language with expressive syntax, cross platform support, and a rich standard library. Its primary aim is to allow developers to write platform agnostic programs that can run anywhere, and require little or no platform- or os- specific code.

    You're currently reading the manual, which is a formal specification of the language, builtins, standard library, and semantics.
    },
    {Why is kscript?}, {kscript was designed to be a tool useful in many different circumstances – as a computer calculator, as a task-automation language, GUI development language, numerical programming, and more. A few languages may come to mind – namely Python, tcl, and so forth.

    I found that I had issues with some choices the Python team made. Syntactically, I dislike required/syntactically-significant whitespace, and dislike Python’s overuse of `:`. . I feel that many Python modules (for example, the operating system module) do not give the best interface to their functionality, and often require the programmer to use platform-specific code. I’d like to conclude this paragraph with a redeeming note – Python has been very successful and I largely do enjoy the language (even though I have my complaints), and even borrow the great ideas Python has had.
    },
    {Who is kscript?}, {kscript is developed by free software enthusiasts, under the organization {@url https://chemicaldevelopment.us, ChemicalDevelopment}. Feel free to contact current authors with questions, comments, or concerns at any time:

    {@list
        {@url mailto:cade@@kscript.org, Cade Brown <cade@@kscript.org>},
        {@url mailto:greg@@kscript.org, Gregory Croisdale <greg@@kscript.org>}
    }

    }


@node Philosophy, {Design decisions, and high-level overview of how everything works}, {
This section contains the design philosophy of kscript

@node Patterns, {Duck-typing concept}, {
Patterns in kscript refer to sets of {@ref Magic Attributes, magic attributes} and/or methods that objects are expected to have in order to fulfill a certain purpose. Objects that have those attributes and/or methods are said to "fit" a given pattern, and can be used like other objects that fit that pattern -- this is the basis of all {@url https://en.wikipedia.org/wiki/Duck_typing, duck-typed} programming languages.

Patterns are a similar concept to what are called interfaces or contracts in other language, but in practice are much more dynamic, as the developer doesn't need to specify the pattern that the object fits. You can think of interfaces/contracts as a more formal specification, whereas patterns are dynamic and only require that a given attribute/method is available when a function expects it to be. If the attribute/method is unavailable, the function processing it will likely throw an error explaining that it does not have the expected attribute and/or method.


Although the type does not matter for a pattern (objects of any type may fit a pattern), many patterns will have an abstract base type which other types are subtypes of. This is primarily done to simplify code and reduce redundancy (i.e. if all subtypes re-implemented the pattern handling code, then there would be code bloat and duplication). However, this is not required and is only done to simplify the implementation in most cases (or, for some sense of type-hierarchy purity).

Some examples of patterns in the standard library are:

@list
    {Number pattern, documented by the abstract base type $number},
    {IO pattern, documented by the abstract base type $io.BaseIO}

}
@node Magic Attributes, {Duck-typing concept}, {
Magic attributes are the name we use to describe how the standard library (or external packages) inspect objects to determine how to use them for a particular purpose. 

For example, when `int(x)` is called, and `x` is an unfamiliar type (for example, a custom type), how does kscript know how to convert it to an integer? Well, for converting to integers, there is a well established magic attribute called $__int, which is searched for on `x` (for example, `x.__int()` is attempted). If that does not work, there is a secondary magic attributed called $__integral, which is then searched (`x.__integral()` is attempted). If both of those fail, then a $TypeError is thrown with a message explaining that `x` could not be converted to an $int. However, if one of those did succeed, then its return value is expected to be an integer, and kscript can use it as the return value.


The above was just an example, but it shows how specially named attributes allow for different libraries and programs to communicate and translate objects into known quantities for processing. This section contains examples and commonly used magic attributes that you can use in your own code to write easier-to-use libraries and programs.


@dict
    {__int()}, {Used for direct conversion to $int. Should return an $int. Also see $__integral},
    {__integral()}, {Used for integral value conversion. Sshould return an $int. Also see $__int},

    {__bool()}, {Used for conversion to $bool, Should return a $bool},

    {__bytes()}, {Used for direct conversion to $bytes. Should return a $bytes},
    {__str()}, {Used for direct conversion to $str. Should return a $str},
    {__repr()}, {Used for string representation (for example, the $repr function). Should return an $str},
    {__hash()}, {Used for computing a {@url https://en.wikipedia.org/wiki/Hash_function, hash} of an object. Should return an $int},
    {__len()}, {Used for computing the length of a container, which is typically the number of elements. Should return an $int},

}



@node Templates, {Feature on specific types}, {

}

}



@node Syntax, {Language specification and grammar rules}, {

This section describes the syntax of the ksript language. It explains the actual formal specs of what is and what is not valid kscript code.


@node EBNF, {Formal specification}, {

{@url https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form, EBNF} is a notation to formalize computer grammars. In this page, the grammar of the kscript language is described using an EBNF-like syntax:


```
(* Entire program/file *)
PROG    : STMT*

(* Newline/break rule *)
N       : '\n'
        | ';'

(* Block (enclosed in '{}') *)
B       : '{' STMT* '}'

(* Block (B) or comma statement *)
BORC    : B
        | ',' STMT

(* Block (B) or statement *)
BORS    : B
        | STMT

(* Statement, which does not yield a value *)
STMT    : 'import' NAME N
        | 'ret' EXPR? N
        | 'throw' EPXR? N
        | 'break' N
        | 'cont' N
        | 'if' EXPR BORC ('elif' BORC)* ('else' EXPR BORS)?
        | 'while' EXPR BORC ('else' EXPR BORS)?
        | 'for' EXPR BORC
        | 'try' BORS ('catch' EXPR (('as' | '->') EXPR)?)* ('finally' BORS)?
        | EXPR N
        | N

(* Expression, which does yield a value *)
EXPR        : E0

(* Precedence rules *)
E0      : E1 '=' E0
        | E1 '&=' E0
        | E1 '^=' E0
        | E1 '|=' E0
        | E1 '<<=' E0
        | E1 '>>=' E0
        | E1 '+=' E0
        | E1 '-=' E0
        | E1 '*=' E0
        | E1 '@=' E0
        | E1 '/=' E0
        | E1 '//=' E0
        | E1 '%=' E0
        | E1 '**=' E0
        | E1

E1      : E2 'if' E2 ('else' E1)?
        | E2

E2      : E2 '??' E3
        | E3

E3      : E2 '||' E3
        | E3

E4      : E4 '&&' E5

E5      : E5 '===' E6
        | E5 '==' E6
        | E5 '!=' E6
        | E5 '<' E6
        | E5 '<=' E6
        | E5 '>' E6
        | E5 '>=' E6
        | E5 'in' E6
        | E5 '!in' E6
        | E6
        | E7

E6      : E6 '|' E7
        | E7

E7      : E7 '^' E8
        | E8

E8      : E8 '&' E9
        | E9

E9      : E9 '<<' E10
        | E9 '>>' E10
        | E10

E10     : E10 '+' E11
        | E10 '-' E11
        | E11

E11     : E11 '*' E12
        | E11 '@' E12
        | E11 '/' E12
        | E11 '//' E12
        | E11 '%' E12
        | E12

E12     : E13 '**' E12
        | E13

E13     : '++' E13
        | '--' E13
        | '+' E13
        | '-' E13
        | '~' E13
        | '!' E13
        | '?' E13
        | E15

E14     : E14 '.' NAME
        | E14 '++'
        | E14 '--'
        | E14 '(' (ARG (',' ARG)*)? ','? ')'   (* Function call *)
        | E14 '[' (ARG (',' ARG)*)? ','? ']'   (* Subscript call *)
        | TUPLE
        | LIST
        | SET
        | DICT
        | ATOM
        | FUNC
        | TYPE
        | ENUM

(* Atomic element of grammar (expression which is single token) *)
ATOM    : NAME
        | STR
        | REGEX
        | INT
        | FLOAT
        | '...'

(* Valid argument to function call *)
ARG     : '*' EXPR
        | EXPR

(* Valid parameter to a function *)
PAR     : '*' NAME
        | NAME ('=' EXPR)?

(* Valid argument to container constructor (expression, or expand expression) *)
ELEM    : '*' EXPR
        | EXPR

(* Valid argument to key-val container constructor *)
ELEMKV  : EXPR ':' EXPR


(* Tuple literal *)
TUPLE   : '(' ','? ')'
        | '(' ELEM (',' ELEM)* ','? ')'

(* List literal *)
LIST    : '[' ','? ']'
        | '[' ELEM (',' ELEM)* ','? ']'

(* Set literal (no empty set, since that conflicts with dict) *)
SET     : '{' ELEM (',' ELEM)* ','? '}'

(* Dict literal *)
DICT    : '{' ','? '}'
        | '{' ELEMKV (',' ELEMKV)* ','? '}'

(* Function constructor *)
FUNC    : 'func' NAME? ('(' (PAR (',' PAR)*)? ','? ')')? B

(* Type constructor *)
TYPE    : 'type' NAME? ('extends' EXPR)? B

(* Enum constructor *)
ENUM    : 'enum' NAME? B


(* Token kinds described as literals *)
NAME    : ? unicode identifier ?
STR     : ? string literal ?
REGEX   : ? regex literal ?
INT     : ? integer literal ?
FLOAT   : ? floating point literal ?

```

}

@node Expressions, {Syntax elements yielding a result}, {

In kscript, many syntax elements are {@ref Expressions, expressions}, which means that they will result in a value after being evaluated. You can always assign the result of an expression to a variable, element index, attribute, or any other destination where you may store in any object. They can be used within other expressions (albeit, sometimes requiring `()` due to order-of-operations).

In contrast to most languages, {@ref Function Definitions} and {@ref Type Definitions} are expressions (in most languages, they are statements and do not yield a value). You can, of course, use them like a statement (i.e. not embedded in another expression), but you can also return them, or assign them locally.


@node Integer Literals, {Whole number literal syntax}, {

This is the syntax for constructing literal integers (of type $int). You can specify the base-10 digits within a kscript program, and it will be interpreted as an integer. You can also use a prefix for other notations -- see the table below for a list of valid ones:

{@dict
    {0d}, {{@url https://en.wikipedia.org/wiki/Decimal, Decimal} notation involves the prefix `0d` or `0d` or no prefix followed by a sequence of base-10 digits, which are one of: `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`},
    {0b}, {{@url https://en.wikipedia.org/wiki/Binary_number, Binary} notation involves the prefix `0b` or `0B` followed by a sequence of base-2 digits (called bits), which are either `0` or `1`},
    {0o}, {{@url https://en.wikipedia.org/wiki/Octal, Octal} notation involves the prefix `0o` or `0O` (that's "zero" "oh", as in the number and then letter) followed by a sequence of base-8 digits, which are one of: `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`. A common use of this notation is file permission bits, see: $os.mkdir, $os.stat},
    {0x}, {{@url https://en.wikipedia.org/wiki/Hexadecimal, Hexadecimal} notation involves the prefix `0x` or `0X` followed by a sequence of base-16 digits, which are are one of: `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `a`/`A`, `b`/`B`, `c`/`C`, `d`/`D`, `e`/`E`, `f`/`F`},
}

Regardless of the notation, the result is an $int object with the specified value. Also, note that there are no "negative integer literals" -- only a positive one with a `-` operator, which causes negation. 

Examples:

```ks
>>> 123       # Base-10
123
>>> 255       # Base-10
255

>>> 0x7B      # Base-16
123
>>> 0xFF      # Base-16
255

>>> 0o173     # Base-8
123
>>> 0o377     # Base-8
255

>>> 0b1111011 # Base-2
123
>>> 0b11111111 # Base-2
255
```

}


@node Float Literals, {Real number literal syntax}, {

This is the syntax for constructing literal floating point numbers (of type $float). You can specify the base-10 digits within a kscript program, including a `.` for the whole number/fractional seperator (which differentiates $float literals from {@ref Integer Literals}), and it will be interpreted as a real number, represented as accurately as the machine precision can (see $float.EPS). Additionally, an exponent is allowed (see: {@url https://en.wikipedia.org/wiki/Scientific_notation, scientific notation}) with the `e` or `E` characters. You can also use a prefix for other notations -- see the table below for a list of valid ones:

{@dict
    {0d}, {{@url https://en.wikipedia.org/wiki/Decimal, Decimal} notation involves the prefix `0d` or `0d` or no prefix followed by a sequence of base-10 digits, which are one of: `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`
    },

    {0b}, {{@url https://en.wikipedia.org/wiki/Binary_number, Binary} notation involves the prefix `0b` or `0B` followed by a sequence of base-2 digits (called bits), which are either `0` or `1`. Must include a `.` as a seperator
    
    Instead of using `e` or `E` for the base-10 power, you use `p` or `P` for a base-2 power.
    },
    {0o}, {{@url https://en.wikipedia.org/wiki/Octal, Octal} notation involves the prefix `0o` or `0O` (that's "zero" "oh", as in the number and then letter) followed by a sequence of base-8 digits, which are one of: `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`. Must include a `.` as a seperator

    Instead of using `e` or `E` for the base-10 power, you use `p` or `P` for a base-2 power.
    
    },
    {0x}, {{@url https://en.wikipedia.org/wiki/Hexadecimal, Hexadecimal} notation involves the prefix `0x` or `0X` followed by a sequence of base-16 digits, which are are one of: `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `a`/`A`, `b`/`B`, `c`/`C`, `d`/`D`, `e`/`E`, `f`/`F`. Must include a `.` as a seperator
    
    Instead of using `e` or `E` for the base-10 power, you use `p` or `P` for a base-2 power.
    },
}

In addition to the digits, there are also two builtin names `inf` and `nan`, which represent positive infinity and not-a-number respectively.

Also, note that there are no "negative float literals" -- only a positive one with a `-` operator, which causes negation. 


Regardless of the notation, the result is a $float object with the specified value.

Examples:

```ks
>>> 123.0     # Base-10
123.0
>>> 255.0     # Base-10
255.0
>>> 100.75    # Base-10
100.75

>>> 0x7B.0    # Base-16
123.0
>>> 0xFF.0    # Base-16
255.0
>>> 0x64.C    # Base-16
100.75

>>> 0o173.0   # Base-8
123.0
>>> 0o377.0   # Base-8
255.0
>>> 0o144.6   # Base-8
100.75

>>> 0b1111011.0 # Base-2
123.0
>>> 0b11111111.0 # Base-2
255.0
>>> 0b1100100.11 # Base-2
100.75
```

Here are some examples with scientific notation:

```ks
>>> 1.234e3
1234
>>> 1234e-3
1.234
>>> 1e9
1000000000.0
```
}


@node Complex Literals, {Complex literal syntax}, {

This is the syntax for constructing literal $complex values. Specifically, you can only construct imaginary literals -- you need to use the `+` operator to create a complex number with real and imaginary components.

Complex literals are created by placing an `i` or `I` directly after an {@ref Integer Literal} or {@ref Float Literal}, which results in a complex number with `0.0` as the real component, and the integer or floating point value as the imaginary component. Note that $complex objects have both components as $float values, so even though an integer imaginary component may be given (for example, `123i`), the resulting complex value will have floating point components.


Examples:

```ks
>>> 1i          # Base-10
1.0i
>>> 123i        # Base-10
123.0i
>>> 12+34i      # Base-10
(12.0+34.0i)

>>> 0x1i        # Base-16
1.0i
>>> 0x7Bi       # Base-16
123.0i
>>> 0xC+0x22i   # Base-16
(12.0+34.0i)
```

}


@node String Literals, {String literal syntax}, {

This is the syntax for constructing literal $str values. The basic syntax is a beginning quote character (one of `'`, `"`, `'''`, `"""`), followed by the contents of the string, and then an ending quote character that matched the one the string started with. The contents of the string can be either character literals, or escape codes (see below for a list of escape sequences). The result will always be a $str object, which is immutable.

Here's a list of escape sequences:


{@dict

    {\\\\ }, {A literal `\`},
    {\'}, {A literal `'`},
    {\"}, {A literal `"`},
    {\a}, {An ASCII `BEL` character (bell/alarm)},
    {\b}, {An ASCII `BS` character (backspace)},
    {\f}, {An ASCII `FF` character (formfeed)},
    {\n}, {An ASCII `LF` character (newline/linefeed)},
    {\r}, {An ASCII `CR` character (carriage return)},
    {\t}, {An ASCII `HT` character (horizontal tab)},
    {\v}, {An ASCII `VT` character (bertical tab)},
    {\xXX}, {Single byte, where `XX` are the 2 hexadecimal digits of the codepoint (padded with leading zeros)
Examples:

```ks
>>> '\x61'
'a'
```
    },
    {\uXXXX}, {Unicode character, where `XXXX` are the 4 hexadecimal digits of the codepoint (padded with leading zeros)
Examples:

```ks
>>> '\u0061'
'a'
```
    },
    {\UXXXXXXXX}, {Unicode character, where `XXXXXXXX` are the 8 hexadecimal digits of the codepoint (padded with leading zeros)
Examples:

```ks
>>> '\U00000061'
'a'
```
    },
    {\N[XX...X]}, {Unicode character, where `XX...X` is the {@url https://en.wikipedia.org/wiki/List_of_Unicode_characters, name} of the Unicode character
Examples:

```ks
>>> '\N[LATIN SMALL LETTER A]'
'a'
```
    }


}

}

@node List Literals, {List literal syntax}, {

This is the syntax for constructing literal $list objects. A $list is a mutable collection, so once the literal is created, it may be mutated further.

List literals are created by surrounding the elements of the list with `[` and `]`, with `,` in between each element. Optionally, an additional `,` may be added after all of them. Items within a list literal may span across lines.

An empty list can be created with either `[]` or `[,]` (they are equivalent).

List literals also support unpacking, which can be specified via a `*` before an element in the literal. This instructs kscript to treat that element as an iterable, and instead of adding it, it adds each object within that element to the list.

List literals also support comprehension, which can be specified with the `for` and optionally an `if` keyword. You can use: `a for b in c` (adds the expression `a` for each element `b` in an iterable `c`) or `a for b in c if d` (adds the expression `a` for each element `b` in an iterable `c`, only if the expression `d` is truthy). You can think of this as an inline {@ref For Statement, `for` loop}.


Examples:

```ks
>>> []
[]
>>> [,]
[]
>>> [1, 2, 3]
[1, 2, 3]
>>> ["Any", "Type", "CanBeStored"]
['Any', 'Type', 'CanBeStored']
>>> [*"abcd"]
['a', 'b', 'c', 'd']
```

}

@node Tuple Literals, {Tuple literal syntax}, {

This is the syntax for constructing literal $tuple objects. A $tuple is a immutable collection, so once the literal is created, it may not be mutated further.

Tuple literals are created by surrounding the elements of the tuple with `(` and `)`, with `,` in between each element. Optionally, an additional `,` may be added after all of them. Items within a tuple literal may span across lines. Tuples with one element must end with a comma (i.e. `(a,)`)

The empty tuple can be created via either `()` or `(,)`


Tuple literals also support unpacking, which can be specified via a `*` before an element in the literal. This instructs kscript to treat that element as an iterable, and instead of adding it, it adds each object within that element to the tuple.

Tuple literals also support comprehension, which can be specified with the `for` and optionally an `if` keyword. You can use: `a for b in c` (adds the expression `a` for each element `b` in an iterable `c`) or `a for b in c if d` (adds the expression `a` for each element `b` in an iterable `c`, only if the expression `d` is truthy). You can think of this as an inline {@ref For Statement, `for` loop}.


Examples:

```ks
>>> ()
()
>>> (,)
()
>>> (1, 2, 3)
(1, 2, 3)
>>> ("Any", "Type", "CanBeStored")
('Any', 'Type', 'CanBeStored')
>>> (*"abcd")
('a', 'b', 'c', 'd')
```

}

@node Set Literals, {Set literal syntax}, {

This is the syntax for constructing literal $set objects. A $set is a mutable collection, so once the literal is created, it may be mutated further.

Set literals are created by surrounding the elements of the set with `{` and `}`, with `,` in between each element. Optionally, an additional `,` may be added after all of them. Items within a set literal may span across lines.

Due to a conflicts with {@ref Dict Literals}, the empty set must be created via calling the $set type: `set()`

Set literals also support unpacking, which can be specified via a `*` before an element in the literal. This instructs kscript to treat that element as an iterable, and instead of adding it, it adds each object within that element to the set.

Set literals also support comprehension, which can be specified with the `for` and optionally an `if` keyword. You can use: `a for b in c` (adds the expression `a` for each element `b` in an iterable `c`) or `a for b in c if d` (adds the expression `a` for each element `b` in an iterable `c`, only if the expression `d` is truthy). You can think of this as an inline {@ref For Statement, `for` loop}.


Since $set objects only store unique members (i.e. members which differ in hash and value), adding duplicate elements will result in a shorter $set with fewer elements than intiailizers (see below in examples).


Examples:

```ks
>>> set()
set()
>>> {1, 2, 3}
{1, 2, 3}
>>> {"Any", "Type", "CanBeStored"}
{'Any', 'Type', 'CanBeStored'}
>>> {*"abcd"}
{'a', 'b', 'c', 'd'}
>>> {3, 2, 1, 2, 3}    # Duplicate elements are not added
{3, 2, 1}
```

}


@node Dict Literals, {Dict literal syntax}, {

This is the syntax for constructing literal $dict objects. A $dict is a mutable collection, so once the literal is created, it may be mutated further.

Dict literals are created by surrounding the key-value pairs of the dict with `{` and `}`, with `:` seperating the key and value, and with `,` in between each element. Optionally, an additional `,` may be added after all of them. Items within a dict literal may span across lines.

The empty dictionary can be created via either `{}` or `{,}`.

Dict literals also support unpacking, however the syntax is not finalized yet. This is incomplete.

Dict literals also support comprehension, which can be specified with the `for` and optionally an `if` keyword. You can use: `k: v for b in c` (adds the key-value entry `k` and `v` for each element `b` in an iterable `c`) or `k: v for b in c if d` (adds the key-value entry `k` and `v` for each element `b` in an iterable `c`, only if the expression `d` is truthy). You can think of this as an inline {@ref For Statement, `for` loop}.


Since $dict objects only store unique members (i.e. keys which differ in hash and value), adding duplicate elements will result in a shorter $dict with fewer elements than intiailizers (see below in examples).


Examples:

```ks
>>> {}
{}
>>> {'a': 1, 'b': 2, 'c': 3}
{'a': 1, 'b': 2, 'c': 3}
>>> >>> {'a': 1, 'b': 2, 'c': 3, 'a': 4} # Duplicate elements update the value, but do not add entries
{'a': 4, 'b': 2, 'c': 3}
```

}

}

@node Statements, {Syntax elements which do not yield a value}, {

These elements do not yield a value, and are typically used for control flow.

In contrast to most languages, {@ref Function Definitions} and {@ref Type Definitions} are expressions (in most languages, they are statements and do not yield a value). You can, of course, use them like a statement (i.e. not embedded in another expression), but you can also return them, or assign them locally.

@node Expression Statement, {Executes an expression}, {

The expression statement is an {@ref Expression, expression}, which has a line break after it, or, equivalently, a semicolon (`;`). You can write code without using semicolons (`;`), and it is recommended to not use them. For example, calling `foo()` and `bar()` can be done in a few ways:


```ks
# This is the best, it is clear and readable
foo()
bar()

# Don't do this, the ';' are unnecessary
foo();
bar();

# Don't do this, it's less readable
foo(); bar()

```

However, if there is some circumstance that makes it better to have multiple on the same line, you may have expression statements ended with `;`. This is sometimes useful when creating one liners running with the interpreter, but in production code or code you are sharing with anyone else, you should just put them on seperate lines.

}


@node Assert Statement, {Validating an assertion}, {

The `assert` statement is an example of {@ref https://en.wikipedia.org/wiki/Assertion_(software_development), assertion syntax} for the kscrip language. It instructs the program to evaluate a conditional expression, check whether it is truthy (see $bool), and if it is not truthy, throws an $AssertError up the call stack.

This is done to do "sanity checks" on things which should be a given value, and is encouraged for only internal code checking (i.e. don't check user input with `assert`, use `if` and then {@ref Throw Statements, `throw`} an $Exception yourself). Here is the syntax:

```ks
# Evaluates `x` and asserts that it is true
assert x
```

}



@node Cont Statement, {Continue through a loop}, {

The `cont` statement prematurely terminates the innermost loop (which may be a {@ref While Statement, `while` statement}, or {@ref For Statement, `for` statement}) and retries the next iteration.

As a result, it must be placed within a `while` or `for` statement. For example:

```ks
# infinite loop
while true {
    # Stops executing now, and continues the loop
    cont
    # This code never runs
    x = 3
}
```

See also the {@ref Break Statement}

}



@node Break Statement, {Break a loop}, {

The `break` statement prematurely terminates the innermost loop (which may be a {@ref While Statement, `while` statement}, or {@ref For Statement, `for` statement}) and then stops executing the loop

As a result, it must be placed within a `while` or `for` statement. For example:

```ks
# looks like an infinite loop, but is not since the `break` statement will terminate it
while true {
    # Stops executing now, and exits the loop
    break
    # This code never runs
    x = 3
}
```

See also the {@ref Cont Statement}

}


@node Ret Statement, {Returning a value from a function}, {

The `ret` statement is an example of {@url https://en.wikipedia.org/wiki/Return_statement, return syntax} for the kscript language. It instructs the program to return a value (or `none`) from the current function, and stop executing in that function.

For example:

```ks
# Returns the value `a` and stops executing the current function
ret a

# Equivalent to `ret none`
ret
```

}



@node Throw Statement, {Throwing an exception up the call stack}, {

The `throw` statement is an example of {@url https://en.wikipedia.org/wiki/Exception_handling_syntax, exception handling syntax} for the kscript language. It instructs the program to throw a value up the call stack, which searches through the current functions executing in the {@ref os.thread, thread}, until it finds a {@ref Try Statement, `try` statement}. If it does find a `try` statement, then it is handled to rules according to that syntax. If there were no `try` statements that catch the exception, then the program is halted and the exception is printed (this is called an "unhandled exception").


For example:

```ks
# Throws the value `a` up the call stack
throw a
```

To see how it can work, look at this small example:

```ks
# Innocent enough looking function...
func foo(x) {
    # Some error condition
    if x == 0 {
        throw Exception("'x' should never be 0")
    }

    # Do something else
    ...
}


# Fine
foo(1)
# Fine
foo(2)
# Uh-oh, this crashes and prints: Exception: 'x' should never be 0
# (and, at this point, the program stops)
foo(0)

# Now, wrap in a `try` statement
try {
    foo(0)
} catch as err {
    # This works, and it prints what it caught ("I got: Exception")
    # It doesn't stop the program
    print ("I got:", type(err))
}
```

}

@node If Statement, {Conditional code execution}, {

The `if` statement is an example of a {@url https://en.wikipedia.org/wiki/Conditional_(computer_programming), conditional statement}, which evaluates a condition, and then based on the result (specifically, whether it was truthy or falsey), either runs another {@ref Statements, statement}, or does not. An `if` statement has the following syntax:

```ks
if a {
    b
}
```

Where `a` is an {@ref Expressions, expression}, and treated as the conditional. If `a` is truthy (see $bool), then `b` is executed, which can be zero-or-more {@ref Statements, statements}. After the closing `}`, there may be additional clauses. 

Specifically, there is the `elif` clause:

```ks
if a {
    b
} elif c {
    d
} elif e {
    f
}
```

`c` is only executed if `a` was not truthy. If `c` was truthy, then `d` is executed. Similarly, if `c` was not truthy, then `e` is evaluated, and if it is truthy then `f` is executed. You can stack as many `elif` clauses as you want.

There is also the `else` clause, which is given after the `if` and `elif` parts (it must be the last). The syntax is:


```ks
if a {
    b
} elif c {
    d
} elif e {
    f
} else {
    g
}
```

`g` is only executed if `a`, `c`, and `e` were all falsey.


Sometimes, it is advantageous or more consise to have an `if` statement without using the `{` and `}` surrounding the body. If the body only has a single {@ref Statements, statement}, then you can use this syntax instead:

```ks
if a, b
```

Which is equivalent to:

```ks
if a {
    b
}
```

As long as `b` is only a single statement.

It is always recommended to keep an inline `if` on a single line. For example, do not do the following:

```ks
# THIS IS BAD. DO NOT DO
if a,
    b
```

This is confusing, because the indentation suggests there is another block, and if you had written:

```ks
# THIS IS BAD. DO NOT DO
if a,
    b
    c
```

Then a reader may think that `b` and `c` are both executed if `a` is true, but `c` is actually executed regardless!

}

@node While Statement, {Conditional loop execution}, {

The `while` statement is an example of a {@url https://en.wikipedia.org/wiki/Conditional_(computer_programming), conditional loop}, which evaluates a condition, and then based on the result (specifically, whether it was truthy or falsey), either runs another {@ref Statements, statement} and then retries the condition, or exits the loop. An `while` statement has the following syntax:

```ks
while a {
    b
}
```

Which first evaluates `a`. If `a` is truthy (see $bool), then the body, `b`, is executed (which is zero-or-more {@ref Statements, statements}), and then this process is repeated, re-evaluating `a` and then re-executing `b` if it is truthy. If `a` is falsey, then the loop is exited.

Similar to an {@ref If Statements, `if` statement}, `while` statements allow for additional `elif` clauses and a final `else` clause. The `elif` and `else` clauses are only checked and executed if the conditional, `a`, was falsey on the first time through the loop. So, if `a` was truthy, and then falsey, then none of the `elif` or `else` clauses are checked.

Let's take an example:

```ks
while a {
    b
} elif c {
    d
} else {
    e
}
```

When encountering the `while`, `a` is first evaluated. While it is truthy, `b` is executed, and `a` is rechecked, and `b` is executed again, until `a` is falsey. If `a` was never truthy (which means `b` is not executed at all), then `c` is evaluated. If `c` is truthy, then `d` is executed. Otherwise, if `c` is falsey, `e` is executed.


Sometimes, it is advantageous or more consise to have an `while` statement without using the `{` and `}` surrounding the body. If the body only has a single {@ref Statements, statement}, then you can use this syntax instead:

```ks
while a, b
```

Which is equivalent to:

```ks
while a {
    b
}
```

As long as `b` is only a single statement.

It is always recommended to keep an inline `while` on a single line. For example, do not do the following:

```ks
# THIS IS BAD. DO NOT DO
while a,
    b
```

This is confusing, because the indentation suggests there is another block, and if you had written:

```ks
# THIS IS BAD. DO NOT DO
while a,
    b
    c
```

Then a reader may think that `b` and `c` are both executed if `a` is true, but `c` is actually executed regardless!

}

@node For Statement, {Iterable loop execution}, {

The `for` statement is an {@url https://en.wikipedia.org/wiki/For_loop#Iterator-based_for-loops, iterator-based `for` loop}, which is sometimes called a `foreach` loop. It iterates over elements of an {@ref iter, iterable}. Specifically, you can write a `for` loop like so:

```ks
for a in b {
    c
}
```

Which first evaluates `b`, and treats it as an iterable (see {@ref iter()}). It is iterated over via the {@ref next()} function, until the iterable runs out. For each element, it is assigned to `a` (which must be an assignable {@ref Expressions, expression}), and then the body, `c` (which may be zero-or-more statements), is ran. 

Similar to an {@ref If Statements, `if` statement}, `for` statements allow for additional `elif` clauses and a final `else` clause. The `elif` and `else` clauses are only checked and executed if the iterable, `b`, was empty on the first time through the loop. So, if `b` had any elements, and then runs out, then none of the `elif` or `else` clauses are checked.

Let's take an example:

```ks
for a in b {
    c
} elif d {
    e
} else {
    f
}
```

When encountering the `for`, `b` is first evaluated and turned into an iterable via the {@ref iter()} function. While there is another element (by calling the {@ref next()} function), it is assigned to `a` (which should be an assignable expression). Then, the code block `c` is executed (which is expected to be zero-or-more {@ref Statements, statements}). If it was empty (i.e. `c` was never ran, and `a` was never assigned to), then it goes through the `elif` clauses. In this case, it evaluates `d` and checks whether it was truthy. If it was, then `e` is executed. Otherwise, `f` is executed.

Sometimes, it is advantageous or more consise to have an `for` statement without using the `{` and `}` surrounding the body. If the body only has a single {@ref Statements, statement}, then you can use this syntax instead:

```ks
for a in b, c
```

Which is equivalent to:

```ks
for a in b {
    c
}
```

As long as `b` is only a single statement.

It is always recommended to keep an inline `for` on a single line. For example, do not do the following:

```ks
# THIS IS BAD. DO NOT DO
for a in b,
    c
```

This is confusing, because the indentation suggests there is another block, and if you had written:

```ks
# THIS IS BAD. DO NOT DO
for a in b,
    c
    d
```

Then a reader may think that `b` and `c` are both executed if `a` is true, but `c` is actually executed regardless!

}

@node Try Statement, {Exception handling construct}, {

The `try` statement (also called `try/catch` statement) is the {@ref https://en.wikipedia.org/wiki/Exception_handling_syntax, exception handling syntax} for kscript. It allows exceptions thrown with the {@ref Throw Statement, `throw` statement} while executing the body of the `try` statement to be "caught", and then handled appropriately.


There are a few variations of the `try` statement. Specifically, the `catch` clauses may differ. All `try` statements begin with the format:

```ks
try {
    a
}
```

Here, `a` is the "body" of the `try` statement. Then, like `elif` and `else` clauses in the {@ref If Statement, `if` statement}, there may be any number of `catch` clauses, and then, optionally, a `finally` clause as well. Also, like `elif` and `else` clauses in an `if` statement, only one body of the `catch` clause can be ran. It checks the `catch` clauses sequentially, and the first type specifier that is a match (or, if the type specifier was ommitted, any exception matches) it runs the corresponding block, and does not check subsequent `catch` clauses

Here are the variations of the `catch` clause:


```ks
try {
    a
} catch NameError {
    # This is only selected if the exception thrown was a subtype of `NameError`
} catch NameError as err {
    # This is only ran if the exception thrown was a subtype of `NameError`, and captures
    #   the thrown object as the local name `err`
    print (err)
} catch (NameError, SizeError) as err {
    # This is only selected if the exception thrown was a subtype of `NameError` or `SizeError`, and
    #   captures the thrown object as the local name `err`
    # You can include however many elements in the tuple as you want, this will match an exception
    #   which is a subtype of any of the elements within the tuple
} catch {
    # This is selected for any thrown exception
} catch as err {
    # This is selected for any thrown exception, and captures the thrown object as the local name `err`
}
```

And, after all the `catch` clauses, there is also, optionally, a `finally` clause which is allowed:

```ks
try {
    a
} catch {
    ...
} finally {
    b
}
```

`b` is executed whether an exception was thrown, or handled, or not. It is always ran after `a`, and after a catch block (if one is ran at all). These are normally used to close resources which need to be closed whether the exception occurs or not. And, it allows the developer to put shared code here instead of in each `catch` clause.

Just to explain further:

{@list {If `a` is executed and no exception occurs, it then runs `b`}, {If `a` is executed an exception occurs, and is handled in a `catch` clause, it then runs `b`}, {If `a` is executed and an exception occurs, and is not handled in a `catch` clause, it then runs `b`, and then re-throws the exception, going up the call stack finding the next `try` statement, or causing the program to halt and print the unhandled exception}}

}

}

}

@node Builtins, {Types, functions, and values available everywhere}, {

Builtins in kscript are the types, functions, and values that are available in the global namespace and thus available everywhere without the use of `import` statements. They are the most fundamental objects in kscript and are used most frequently, and so they are also made easiest to remember and type. Although kscript is duck-typed, using the builtin types is often recommended, as they have good performance and easy-to-use APIs.

Since kscript is a {@url https://en.wikipedia.org/wiki/Object-oriented_programming, purely object-oriented language}, everything in kscript is an instance of the $object type, either directly or indirectly. This means that even types are objects, and can be treated generically as such. So can functions. This is in steep contrast to more static programming languages like C, C++, Rust, and so forth, which allow some limited compile time reflection, but little to no runtime inspection of types. kscript, however, is completely dynamic and allows things that other programming languages just can't offer. Here are a few examples:

@list
    {Container types ($list, $tuple, $dict, ...) can store objects of any types, and multiple objects of different types},
    {Iterable types may yield objects of any types, and multiple objects of different types},
    {Objects which are not $func instances may also be callable, if they implement the $__call attribute}


@node Types, Builtin types, {

@cdict
    {object()}, {The most generic type, which is the common type that all other types are derived from. The code `isinst(x, object)` always returns true, no matter what object `x` refers to.
    
    Objects can be created via the constructor, `object()`, which returns a blank objects that has writeable and readable attributes},

    {type(obj)}, {This type is what other types are an instance of. `type` is also an instance of `type`.
    
    Unlike most other types, the code `type(x)` does not created a new type; rather, it returns the type of `x`},

    {number(obj=0)}, {This type is the abstract base type of all other builtin numeric types ($int, $bool, $float, $complex). 
    
    By default, `number()` will return the integer `0`. You can pass it any numeric type and it will return one of the builtin numeric types (or throw an error if there was a problem). You can also call it with a string, and it will parse the string and return a builtin numeric type.
    
    This type also defines and implements stubs for the "number {@ref Patterns, pattern}", which dictates how numeric types should behave. Specifically, an object `obj` is said to follow the number pattern if at least one of the following {@ref Magic Attributes, magic attributes} holds:
    @list
        {If `obj.__integral()` exists, `obj` is assumed to be an integer, and this method should return an $int with an equivalent numerical value},
        {If `obj.__float()` exists, `obj` is assumed to be a real floating point number, and this method should return a $float with an equivalent numerical value},
        {If `obj.__complex()` exists, `obj` is assumed to be a complex floating point number, and this method should return a $complex with an equivalent numerical value}

    Operations between numbers use type coercion, with the following rules (unless otherwise stated):

    {@list
        {If all operands are integers, then an integer result is returned},
        {If all operands are either integers or real floating point numbers, then a real floating point result is returned},
        {If none of the above are applicable, then at least one operand must be a complex floating point number, and a complex floating point result is returned}
    }
    },

    {int(obj=0, base=none)}, {This type describes {@url https://en.wikipedia.org/wiki/Integer, integers} (i.e. whole numbers). This type is a subtype of $number, and subscribes to the $number {@ref Patterns, pattern}. You can create integers with {@ref Integer Literals, integer literals}, or through using this type as a constructor. If `obj` is a string, then `base` can also be given, which is an integer describing the base format that the string is in.
    
    See: {@ref Integer Literals} for creating literals

    Some languages (C, C++, Java, and so forth) have sized integer types which are limited to machine precisions (see: {@ref https://en.wikipedia.org/wiki/Integer_(computer_science), here}). For example, a 32 bit unsigned integer may only represent the values from {@math 0} to {@math 2^\{32\}-1}. However, in kscript, all integers are of arbitrary precision – which means they may store whatever values can fit in the main memory of your computer (which is an extremely large limit on modern computers, and you are unlikely to hit that limit in any practical application).
    
    },

    {bool(obj=false)}, {This type describes {@url https://en.wikipedia.org/wiki/Boolean_data_type, booleans}. There are two boolean values, `true` and `false`. Sometimes, these are referred to as `0`/`1`, `on`/`off`, or even `yes`/`no`. `true` and `false` are keywords which result in these values.
    
    You can convert an object to a boolean (its "truthiness", or "truth" value) via this type as a function. For example, `bool(x)` turns `x` into its truthiness value, or, equivalently, `x as bool`. Typically, types that have custom truthiness logic work as expected -- numbers convert to `true` if they are non-zero, containers convert to `true` if they are non-empty, and so on. In general, if `bool(x) == true`, then `x` is non-empty, non-zero, and/or valid. Otherwise, it is empty, zero, or perhaps invalid. Specific types may overload it in a way that makes sense for them, so always beware of types that override this functionality.

    This conversion to bool is dictated by the $__bool {@ref Magic Attributes, magic attribute}.


Examples:

```ks
>>> bool()
false
>>> bool(false)
false
>>> bool(true)
true
>>> bool(0)
false
>>> bool(1)
true
>>> bool(255)
true
>>> bool('')
false
>>> bool('AnyText')
true
```



    },


    {float(obj=0.0, base=none)}, {This type describes {@url https://en.wikipedia.org/wiki/Floating-point_arithmetic, floating point} numbers. This type is a subtype of $number, and subscribes to the $number {@ref Patterns, pattern}. You can create floats with {@ref Float Literals, float literals}, or through using this type as a constructor. If `obj` is a string, then `base` can also be given, which is an integer describing the base format that the string is in.

    See: {@ref Float Literals} for creating literals
    
    In addition to real numbers, this type can also represent infinity (positive and negative) (via `inf` and `-inf`), as well as not-a-number (via `nan`) values.

    {@dict
        {float.EPS}, {The difference between 1.0 and the next largest number
```ks
>>> float.EPS
2.22044604925031e-16
```
        },
        {float.MIN}, {The minimum positive value representable as a $float
```ks
>>> float.MIN
2.2250738585072e-308
```
        },
        {float.MAX}, {The maximum positive (finite) value representable as a $float
```ks
>>> float.MAX
1.79769313486232e+308
```
        },
        {float.DIG}, {The number of significant digits that can be stored in a $float
```ks
>>> float.DIG
15
```
        },
    }
    
    },

    {complex(obj=0.0+0.0i)}, {This type describes a {@url https://en.wikipedia.org/wiki/Complex_number, complex number} with a real and imaginary components (which can take on any $float values). You can access those elements via the `.re` and `.im` attributes, which will result in $float objects.
    
    See: {@ref Complex Literals} for creating literals

    {@dict
        {.re}, {Real component of a complex number, as a $float
        
```ks
>>> (2 + 3i).re
2.0
>>> (3i).re
0.0
>>> (2 + 0i).re
2.0
```
        },
        {.im}, {Imaginary component of a complex number, as a $float
        
```ks
>>> (2 + 3i).im
3.0
>>> (3i).im
3.0
>>> (2 + 0i).im
0.0
```
},
    }
    },


    {str(obj='')}, {This type describes a {@url https://en.wikipedia.org/wiki/String_(computer_science), string}, which is a sequence of 0-or-more {@url https://en.wikipedia.org/wiki/Unicode, Unicode} characters. It is the basic unit of textual information in kscript, and can store any Unicode sequence. All operations are in terms of characters (also called codepoints), and not neccessarily bytes.

    Some languages have a different type for a single character and a string. However, in kscript, a character is simply a string of length 1. And, the empty string is the string of length 0. Additionally, strings are immutable (which means they cannot be changed). For example, `x[0] = 'c'` will throw an error in kscript. Instead, you should use slicing and re-assign to the same name: `x = 'c' + x[1:]`.

    You can create a string via calling this type as a function with an argument (default: empty string). For non-$str objects, conversion depends on the $__str {@ref Magic Attributes, magic attribute}, which is expected to return a $str.
    
    See {@ref String Literals} for creating literals.

    Internally, kscript uses {@url https://en.wikipedia.org/wiki/UTF-8, UTF-8} to store the textual information.

    Strings can be added together with the `+` operator, which concatenates their contents. For example, `'abc' + 'def' == 'abcdef'`

    },


    {bytes(obj='')}, {This type represents a bytestring, which is similar to $str. The main difference being that $str is a sequence of Unicode characters, whereas $bytes is a sequence of bytes -- which may or may not be textual data.

    You can create a bytestring by calling this type as a function with an argument (default: empty bytestring). For non-$bytes objects, conversion depends on the $__bytes {@ref Magic Attributes, magic attribute}. Commonly, calling `bytes(x)` where `x` is a $str will result in the {@url https://en.wikipedia.org/wiki/UTF-8, UTF-8} bytes of that string.

    },

}

@node Functions, Builtin functions, {

@cdict
    {print(*args)}, {Prints all of `args` to the standard output ($os.stdout), by converting each one to a string, and adding a space between each argument. After all elements are printed, a newline is also printed.
    
    For finer grained control of output format see the $printf function},

    {printf(fmt, *args)}, {Prints all of `args`, formatted with `fmt`. No newline or spaces are added between arguments or after all of them.
    
    The format string, `fmt`, is expected to be made up of format specifiers and normal printable text. A format specifier is started with the character `%` (percent sign), and followed by fields, which control how the object is converted. Finally, each format specifier ends with a single character denoting the type. Text in between format specifiers is output verbatim without modification
    
    Flags are optional characters that change the formatting for a specifier. All flags for a format specifier should be placed immediately after the %. Although different types may treat flags differently, generally their behavior is: {@list {`+` causes the sign of numeric outputs to always be included (so, even positive numbers will have their sign before the digits)}, {`-` causes the output to be left-aligned instead of right-aligned}, {`0` causes the output of right-aligned numbers to contain leading 0s instead of spaces}}
    
    After flags, there is an optional width field which can be an integer (for example, `%10s` has a width of `10`), or a `*`, which takes the next object from args, treats it like an integer, and treats that as the width (dynamic width).

    After width, there is an optional precision field which can be a `.` followed by an integer (for example `%.10s` has a precision of `10`), or `.*`, which takes the next object from args, treats it like an integer, and treats that as the precision (dynamic precision).

    Finally, there is the single-character format specifier which tells the type of output. Below are a table of specifiers:
    
    {@dict
        {%%}, {A literal `%` is added, and no more objects from the arguments are consumed},
        {%i, %d}, {The next object from `args` is consumed, interpreted as an integer, and the base-10 digits are added},
        {%b}, {The next object from `args` is consumed, interpreted as an integer, and the base-2 digits are added},
        {%o}, {The next object from `args` is consumed, interpreted as an integer, and the base-8 digits are added},
        {%x}, {The next object from `args` is consumed, interpreted as an integer, and the base-16 digits are added},
        {%f}, {The next object from `args` is consumed, interpreted as a floating point number, and the base-10 digits are added},
    }

    Examples:

```ks
>>> printf('|%i|', 123)      # Direct translation
|123|
>>> printf('|%5i|', 123)     # Pads to size 5
|123  |
>>> printf('|%+5i|', 123)    # Pads to size 5, and always includes sign
|+123 |
>>> printf('|%-5i|', 123)    # Pads to size 5, and is left-aligned
|  123|
>>> printf('|%-+5i|', 123)   # Pads to size 5, and always includes sign, and is left-aligned
| +123|
>>> printf('|%05i|', 123)    # Pads to size 5, and includes leading zeros
|00123|
>>> printf('|%0*i|', 5, 123) # Equivalent, but takes the width argument before the value it prints
|00123|
```

    For formatted output on arbitrary IO objects, see the $io.BaseIO.printf function.
    },

}


@node Exceptions, Builtin error types, {

Exception/Errors can be thrown via the {@ref Throw Statement, `throw` statement} and caught via the {@ref Try Statement, `try` statement}. Anything thrown must be an instance (either directly or indirectly) of the $Exception type.

Exceptions are more general than errors; errors indicate that something has gone wrong, whereas exceptions can be used to disrupt control flow (see $OutOfIterException). Therefore, in `try/catch` sometimes it is recommended to only catch `Error` objects, and allow exceptions to pass upwards.


@cdict
    {Exception(what='')}, {This is the base type of all other exceptions. Only objects which are a subtype of $Exception may be thrown via the `throw` statement (and thus caught via the `try/catch` construct). Unlike most patterns in kscript (see {@ref Patterns}), exception throwing requires the type of the object being thrown to be a derived type of this, instead of simply having magic attributes.
    
    @dict
        {.what}, {A string object that contains an explanation of the exception}
    },
    {OutOfIterException()}, {This error is thrown whenever an iterable runs out of elements. For example, when $next is called but no more elements are left
    
    Exceptions of this type are automatically caught by `for` loops, which tell the loop to stop running
    
    This is a subtype of $Exception},

    {Error(what='')}, {Generic error which means something bad happened and the operation could not be completed. Generally, $Exception types can be used to alter control flow and not neccessarily signal an error (for example, $OutOfIterException being used by `for` loops). However, this type and its subtypes are used to indicate such an error that should cause a program to halt (unless caught)
    
    This is a subtype of $Exception},

    {InternalError(what='')}, {Errors of this type are thrown when something internally isn't working. Sometimes, it may signal a bug in kscript (such as an unexpected status, unexpected configuration, etc), or it may signal a C library returned something it promised not to.

    In any case, these errors are hard to correct for, and when one is thrown, the status of the interpreter itself and objects that were mutated cannot be guaranteed to be predictable},

    {SyntaxError(what='')}, {Errors of this type are generally thrown at parsing time when a program is invalid, which could mean a number of things (unexpected tokens, invalid constructs, invalid characters, and so forth). Generally they have a descriptive message and highlight the offending part of the code, for easy debugging.
    
    Examples:

```ks
# Some of this code is invalid...
>>> for }
SyntaxError: Unexpected token
for }
    ^
@ Line 1, Col 5 in '<expr>'
Call Stack:
In <thread 'main'>
>>> 2def
SyntaxError: Unexpected token, expected ';', newline, or EOF after
2def
 ^~~
@ Line 1, Col 2 in '<expr>'
Call Stack:
In <thread 'main'>
```
    },

    {ImportError(what='')}, {Errors of this type are generally thrown when importing a module fails, for whatever reason, including: missing dependencies, no such module, and error during initialization.

    Examples:

```ks
>>> import asdf
ImportError: Failed to import 'asdf'
>>> import crazy_name_that_doesnt_exist
ImportError: Failed to import 'crazy_name_that_doesnt_exist'
```
    },

    {TypeError(what='')}, {Errors of this type are thrown when the $type of an object doesn't match what is expected, or the type lacks an expected attribute (i.e. does not follow a {@ref Patterns, pattern}).

Examples:

```ks
>>> int([])
TypeError: Could not convert 'list' object to 'int'
```
    },
    

    {TemplateError(what='')}, {Errors of this type are thrown when a type is {@ref Templates, templated} incorrectly, or an operation is forbidden by a template.

Examples:

```ks
>>> object[]
TemplateError: 'object' cannot be templated
```

This type is a subtype of $TypeError
},

    {NameError(what='')}, {Errors of this type are thrown when a variable/function/module name is used but has not been defined

Examples:

```ks
>>> asdf
NameError: Unknown name: 'asdf'
Call Stack:
  #0: In '<expr>' (line 1, col 1):
asdf
^~~~
In <thread 'main'>
```
},

    {AttrError(what='')}, {
Errors of this type are thrown when any of the following things occur:

@list
  {An attribute is requested on an object that doesn't have any such attribute},
  {An attribute is read-only, but some code attempts to change it}


Examples:

```ks
>>> object().a
AttrError: 'object' object had no attribute 'asdf'
Call Stack:
  #0: In '<expr>' (line 1, col 1):
object().asdf
^~~~~~~~~~~~~
In <thread 'main'>
```
},



    {KeyError(what='')}, {
Errors of this type are thrown when any of the following things occur:

@list
  {A key to a container (for example, a $dict) is not found when searched},
  {A key to a container is invalid (for example, $dict keys must be $hash -able)}

Examples:

```ks
>>> x = { 'a': 1, 'b': 3 }
{ 'a': 1, 'b': 3 }
>>> x['c']
KeyError: 'c'
Call Stack:
  #0: In '<inter-2>' (line 1, col 1):
x['c']
^~~~~~
In <thread 'main'>
```

},



    {IndexError(what='')}, {

Errors of this type are thrown when any of the following things occur:

@list
  {A index to a sequence (for example, a $list) is out of range}


Examples:

```ks
>>> x = ['a', 'b']
['a', 'b']
>>> x[3]
KeyError: Index out of range
Call Stack:
  #0: In '<inter-5>' (line 1, col 1):
x[2]
^~~~
In <thread 'main'>
```

This type is a subtype of the $KeyError type

},


    {ValError(what='')}, {
Errors of this type are thrown when a value provided does not match what is expected


Examples:

```ks
>>> nan as int
ValError: Cannot convert 'nan' to int
Call Stack:
  #0: In '<expr>' (line 1, col 1):
nan as int
^~~~~~~~~~
  #1: In int.__new(self, obj=none, base=10) [cfunc]
In <thread 'main'>
```
    },


    {AssertError(what='')}, {Errors of this type are thrown when an {@ref Assert Statement, `assert` statement} has a falsey conditional

Examples:

```ks
>>> assert false
AssertError: Assertion failed: 'false'
Call Stack:
  #0: In '<inter-0>' (line 1, col 1):
assert false
^~~~~~~~~~~~
In <thread 'main'>
```
    },

    {MathError(what='')}, {Errors of this type are thrown when a mathematical operation is given invalid or out of range operands

Examples:

```ks
>>> 1 / 0
MathError: Division by 0
Call Stack:
  #0: In '<expr>' (line 1, col 1):
1 / 0
^~~~~
  #1: In number.__div(L, R) [cfunc]
In <thread 'main'>
>>> import m
>>> m.sqrt(-1)
MathError: Invalid argument 'x', requirement 'x >= 0' failed
Call Stack:
  #0: In '<expr>' (line 1, col 1):
m.sqrt(-1)
^~~~~~~~~~
  #1: In m.sqrt(x) [cfunc]
In <thread 'main'>
>>> m.sqrt(-1 + 0i)  # Make sure to pass a 'complex' in if you want complex output
1.0i
```
    },

    {ArgError(what='')}, {
Errors of this type are thrown when arguments to a function do not match the expected number, or type

Examples:

```ks
>>> ord('a', 'b')
ArgError: Given extra arguments, only expected 1, but given 2
Call Stack:
  #0: In '<expr>' (line 1, col 1):
ord('a', 'b')
^~~~~~~~~~~~~
  #1: In ord(chr) [cfunc]
```
},

    {SizeError(what='')}, {
    Errors of this type are thrown when arguments are of invalid sizes/shapes
},

    {OSError(what='')}, {

Errors of this type are thrown when an error is reported by the OS, for example by setting `errno` in C

This is a {@ref Templates, templated} type, which means there are subtypes based on the type of error expressed. The specific templated types are sometimes platform-specific, and we are currently working to standardize what we can. 

Examples:

```ks
>>> open("NonExistantFile.txt")
OSError[2]: Failed to open 'NonExistantFile.txt' (No such file or directory)
Call Stack:
  #0: In '<expr>' (line 1, col 1):
open("NonExistantFile.txt")
^~~~~~~~~~~~~~~~~~~~~~~~~~~
  #1: In open(src, mode='r') [cfunc]
  #2: In io.FileIO.__init(self, src, mode='r') [cfunc]
In <thread 'main'>
```

    }

}

}

@node Modules, Standard library of kscript, {

This section documents the builtin modules in kscript, of which there are plenty! The general philosophy in kscript is to make APIs as cross-platform and backend-independent as possible. What that means is that standard types, functions, and modules put forth names and functionality that might not directly map to a particular existing library -- even if kscript uses that library internally to perform the functionality. 

You can count on these modules being available in any kscript distribution, and having a reliable API. Unreliable/non-standard functions, types, and variables typically begin with an underscore (`_`), so be weary if using one of those functions, it might not be available everywhere!

A good example of this is the $os module, which uses the C standard library to perform tasks, but the functions will have different and sometimes better suited names to what they actually do.

@node util: Utilities, Utilities Module, {

This module, `util`, implements commonly used datastructures and algorithms that aren't in the {@ref Builtins, builtins}. While they are commonly used, they are not used frequently enough to use the global namespace and thus restrict developers from using those names in their own code. So, you can think of the `util` module as "builtins 2: electric boogaloo".


@cdict
    {util.Queue(objs=none)}, {This type represents a {@url https://en.wikipedia.org/wiki/Queue_(abstract_data_type), queue} which can handle arbitrary objects. It can be created via the constructor, which accepts `objs` (default: none), which is expected to be an iterable containing the elements to initialize the queue from.
    
    The main purpose of a queue over the builtin $list type is that certain operations are much more efficient for a queue. For example, popping from the left and right is {@math O(1)}, whereas with a list they are {@math O(N)} and {@math O(1)} respectively (where {@math N} is the length of the collection). This has large consequences if you are doing the operation over and over for example -- using a queue will reduce runtime drastically.

    A queue is iterable just like a $list, and it iterates in the same order as a list. 

    {@dict
        {util.Queue.pop(self)}, {Pops from the front of the queue (i.e. the `0`th element)
        {@note {This can be confusing, since $list.pop pops from the back of the list (i.e. the last element). Keep in mind the differences}}
        },
        {util.Queue.push(self, *args)}, {Pushes all of `args` to the back of the queue},
    }

    },

    {util.BST(objs=none)}, {This type represents a key-value mapping following the $dict {@ref Patterns, pattern}, implemented using a {@url https://en.wikipedia.org/wiki/Binary_search_tree, Binary Search Tree (BST)}. Unlike $dict, however, keys must be comparable (not neccessarily hashable), and are stored in sorted order (as opposed to insertion order). This is important for algorithms which maintain a sorted list or mapping.
    
    You can construct a BST with the constructor, which accepts a $dict -like mapping, which inserts every key/value pair into a sorted mapping.

    Values for keys can be retreived via indexing: `x[k]` gets the value associated with key `k` in the BST `x`, or throws a $KeyError if no such key exists. Likewise, `x[k] = v` adds (or replaces) the value associated with key `k` in the BST `x` with value `v`.

    You can iterate over the keys in a binary search tree as well:

```ks
>>> x = util.BST({2: 'a', 1: 'b'})
util.BST({1: 'b', 2: 'a'})
>>> for k in x, print (k, x[k])
1 b
2 a
```

Examples:

```ks
>>> x = util.BST({2: 'a', 1: 'b'})
util.BST({1: 'b', 2: 'a'})
>>> 1 in x
true
>>> 3 in x
false
>>> x[0] = 'hey'
>>> x
util.BST({0: 'hey', 1: 'b', 2: 'a'})
```

    },

    {util.Bitset(objs=none)}, {
        This type represents a {@url https://en.wikipedia.org/wiki/Bit_array, bitset} (also called "bit map", "bit array", etc). The general idea is that it can store whether positive integers are in a set or not based on a single integer mask. This type is supposed to behave exactly like the builtin $set type, except it only supports positive integers, and uses {@math O(max(X))} memory (where {@math X} are the elements in the set). Sets use {@math O(N)} memory, where {@math N} is the number of elements in the set.

        Bitsets can be created with an iterable `objs` (default: none), in which case all elements are converted to an integer and added to the set. Additionally, a bitset can be created with a single integer, which represents the bit mask of the entire set (see below).

        If we look at a number decomposed into bits, we can say that if the `i`th bit is set to `1`, then `i` is in the set, and otherwise, `i` is not in the set. For example, the integer `0b11011` corresponds to the integers `0`, `1`, `3`, and `4`. 

        You can convert a bitset into the corresponding integer like so:

```ks
>>> util.Bitset([0, 1, 3, 4]) as int
27
>> bin(27)    # Check binary notation
0b11011
```

        The main advantage of using a bitset over a normal set with integers is speed of common operations. For example, intersection, union, difference, and so forth can be computed extremely efficiently, perhaps 10x faster. So, this type is available for those use cases.

    },
    {util.Graph(nodes=none, edges=none)}, {
        This type is currently being implemented, so this documentation is incomplete.
    }


}


@node os: Operating System, Operating System Module, {

This module, `os`, allows code to interact with the operating system (OS) that the program is running on. For example, creating directories, gathering information about the filesystem, launching threads, launching processes, and accessing environment variables are all covered in this module.

Due to differences between operating systems that kscript can run on, some functionality may be different, or even missing on some platforms. We attempt to document known cases of functions behaving differently or when something is not supported. Typically, an error is thrown whenever something is not available on a particular platform.

@cdict

    os.argv, {List of commandline arguments passed to the program. Typically, `os.argv[0]` is the file that was ran, and `os.argv[1:]` are the arguments given afterward},
    os.stdin, {A readable $io.FileIO object representing the input to the program},
    os.stdout, {A writeable $io.FileIO object representing the output from the program},
    os.stderr, {A writeable $io.FileIO object representing the error output from the program},
    
    {os.getenv(key, defa=none)}, {Gets an {@url https://en.wikipedia.org/wiki/Environment_variable, environment variable} corresponding to `key` (which is expected to be a string)
    
    In the case that `key` did not exist in the environment, this function's behavior depends on whether `defa` is given. {@list {If `defa` is given, then it is returned}, {Otherwise, an $OSError is thrown}}},


    {os.setenv(key, val)}, {Sets an {@url https://en.wikipedia.org/wiki/Environment_variable, environment variable} corresponding to `key` (which is expected to be a string) to `val` (which is also expected to be a string)
    
    In the case that something went wrong (i.e. an invalid name, general OS error), an $OSError is thrown},


    {os.cwd()}, {Get the current {@url https://en.wikipedia.org/wiki/Working_directory, working directory} of the process, as an $os.path object
    
    To retrieve it as a string, the code `os.getcwd() as str` can be used
    
    To change the working directory, see the $os.chdir function},


    {os.chdir(path)}, {Set the current {@url https://en.wikipedia.org/wiki/Working_directory, working directory} of the process to `path`. `path` is expected to be either a string or an $os.path object
    
    If `path` did not exist, or for some other reason the operation failed (i.e. permissions), an $OSError is thrown},


    {os.mkdir(path, mode=0o777, parents=false)}, {Creates a directory on the filesystem at `path`, with mode `mode`. Mode is expected to be a {@url https://en.wikipedia.org/wiki/File-system_permissions#Numeric_notation, octal numerical notation} of the file permission bits (default: allow everything for everybody)
    
    If `parents` is truthy, then parents of `path` that do not exist are created recursively. If `parents` is false, then an error is raised when trying to create a directory within another directory that does not exist yet},

    {os.rm(path, parents=false)}, {Removes a file or directory `path` from the filesystem
    
    If `path` refers to a directory, then the behavior depends on `parents`: {@list {If `parents` is truthy, then non-empty directories have their contents recursively deleted}, {Otherwise, `path` will only be removed if it is empty; otherwise this function will throw an $OSError}}},

    {os.listdir(path)}, {Returns a tuple of `(dirs, files)` representing the directories and files within the directory `path`, respectively. Note that the elements within the lists `dirs` and `files` are string objects, and not $os.path objects. The entries `'.'` and `'..'` are never included in `dirs`
    
    If `path` is not a directory, this function throws an $OSError},

    {os.stat(path)}, {Queries information about the file or directory `path` on the filesystem. This is a type that can be used as a function to perform such a query
    
    It has the following attributes: 
    @dict
        .dev, {Device ID, which is typically encoded as major/minor versions. This is OS-specific typically}, 
        .inode, {The {@url https://en.wikipedia.org/wiki/Inode, inode} of the file or directory on disk as an integer}, 
        .gid, {The group ID of the owner}, 
        .uid, {The user ID of the owner}, 
        .size, {The size, in bytes, of the file}, 
        .mode, {The mode of the file, represented as a bitmask integer}, 
        .mtime, {The time of last modification, in seconds-since-epoch, as a floating point number (see the $time module)},
        .atime, {The time of last access, in seconds-since-epoch, as a floating point number (see the $time module)},
        .ctime, {The time of last status change, in seconds-since-epoch, as a floating point number (see the $time module)}
    },


    {os.lstat(path)}, {Queries information about the file or link or directory `path` on the filesystem. Equivalent to $os.stat, except for the fact that this function does not follow symbolic links (and thus, if called with a symbolic link, queries information about the link itself, rather than the path that it points to). Returns an $os.stat object
    },

    {os.fstat(fd)}, {Queries information about an open file descriptor `fd` (which is expected to be an integer, or convertible to one). Returns an $os.stat object
    
    Examples:

```ks
>>> os.fstat(os.stdin)
<os.stat ...>
>>> os.fstat(os.stdin.fileno) # os.stdin.fileno == os.stdin as int
<os.stat ...>
```
    },

    {os.pipe()}, {Creates a new pipe, and returns a tuple of `(readio, writeio)`, which are the readable and writeable ends of the pipe, respectively. Both objects are of type $io.RawIO},
    
    {os.dup(fd, to=-1)}, {Duplicates an open file descriptor `fd` (which should be an integer, or convertible to one)
    
    If `to < 0`, then this function creates a new file descriptor and returns the corresponding $io.RawIO object. Otherwise, it replaces `to` with a copy of the source of `fd`},


    {os.exec(cmd)}, {Executes `cmd` (which should either be a string, or a list of strings) as if it was typed into the system shell, and return the exit code as an integer
    
    {@note See $os.proc type for more fine grain control of process spawning}},
    
    {os.fork()}, {Forks the current process, resulting in two processes running the code afterwards. This function returns `0` in the child process, and the PID (process ID) in the parent process (which should be an integer greater than 0)
    
    {@note This function is available on the following platforms: {@list linux, macos, unix}}},


    {os.mutex()}, {This function creates a {@url https://en.wikipedia.org/wiki/Lock_(computer_science), lock} which can be used to restrict access to certain data or code. This is a type which can be used as a function to create an instance
    
    Each mutex starts out unlocked, and then can be locked (or attempted to lock via various functions)

    @dict 
        {os.mutex.lock(self)}, {Locks the mutex, waiting until any other threads which hold the lock to unlock it before it is acquired
        
        {@note {If the same thread which is attempting to lock the mutex has already locked it, a "deadlock" may occur and your program may halt}}},


        {os.mutex.trylock(self)}, {Locks the mutex, if it can be locked instantly, otherwise do nothing. Returns whether it succesfully locked. The mutex should only be unlocked if this function returned true
Example:

```ks
>>> mut = os.mutex()
>>> if mut.trylock() {
...     # Acquired lock, do stuff...
...     mut.unlock() # Must unlock!
... } else {
...     # Failed to acquire lock, do other stuff...
...     # Do not unlock!
... }
```  
        },

        {os.mutex.unlock(self)}, {Unlocks the mutex, waiting until any other threads which hold the lock to unlock it before it is acquired}


    },

    {os.thread(of, args=(), name=none)}, {Creates a new {@url https://en.wikipedia.org/wiki/Thread_(computing), thread} which runs the the function `of` with arguments `args` (default: no arguments), with the name `name` (default: auto-generate a name). This is a type which can be called like a function to create an instance
    
    The thread starts out inactive, you must call `.start()` to actually begin executing
    
    @dict
        {os.thread.start(self)}, {Starts executing the thread},
        {os.thread.join(self)}, {Waits for a thread to finish executing, blocking until it does},
        {os.thread.isalive(self)}, {Polls the thread, and returns a boolean indicating whether the thread is currently alive and executing}


    },
    

    {os.proc(argv)}, {Creates a new {@url https://en.wikipedia.org/wiki/Process_(computing), process} with the given arguments `argv`, which can be either a string, or a list of strings representing the arguments. This is a type which can be called to create an instance.


    @dict
        {.pid}, {The {@url https://en.wikipedia.org/wiki/Process_identifier, process ID}, as an integer},
        {.stdin}, {The standard input of the process, as either an $io.RawIO or $io.FileIO (depending on launch configuration). This is writeable, and can be used to send input to the process},
        {.stdout}, {The standard output of the process, as either an $io.RawIO or $io.FileIO (depending on launch configuration). This is readable, and can be used to read output from the process},
        {.stderr}, {The standard error output of the process, as either an $io.RawIO or $io.FileIO (depending on launch configuration). This is readable, and can be used to read error output from the process},
    
        {os.proc.join(self)}, {Waits for the process to finish executing, and returns the exit code of the process as an integer},
        {os.proc.isalive(self)}, {Polls the process and returns a boolean describing whether the process is still alive and running},
        {os.proc.signal(self, code)}, {Sends an integer signal to the process},
        {os.proc.kill(self)}, {Attempts to kill the process by sending the 'KILL' signal (typically `9`) to the process}
        

    },

    {os.path(path='.', root=none)}, {Creates a path object, which acts similarly to a string (i.e. can be passed to functions such as $os.chdir, $os.stat, and so on) but also can be manipulated at higher levels than a string, which makes it easier to traverse the filesystem, and makes for more readable code than interpreting $os.stat results
    
    A distinction should be made between absolute paths (i.e. those which unambiguously refer to a single file on disk) and relative paths (i.e. those which require a working directory to resolve completely). To convert a string or $os.path object to its absolute path, you can use the $os.real function. Or, the builtin $abs function works on $os.path objects.

    @dict
        {.root}, {Either `none` (for relative paths), or a string representing the start of an absolute path
        
        Since some platforms (most Unix-like ones) use `/` as the root for the filesystem, and other platforms (such as Windows) use drive letters to denote absolute paths (`C:\`, `D:\`, etc), the `.root` may be any of those valid roots, depending on which platform you are on. On all platforms, relative paths have `root==none`
                Examples:
```ks
>>> os.path('/path/to/file.txt').root
'/'
>>> os.path('relative/path/to/file.txt').root
none
```
        },

        {.parts}, {A tuple containing string parts of the path, which is implicitly seperated by directory seperators.
        
        Examples:
```ks
>>> os.path('/path/to/file.txt').parts
('path', 'to', 'file.txt')
>>> os.path('relative/path/to/file.txt').parts
('relative', 'path', 'to', 'file.txt')
```
        },

    },

}
@node time: Time, Time Module, {

This module, `time`, allows code to programmatically determine the current time, convert date-times to human readable formats, create timestamps, and reason about multiple times. 

@cdict
    {time.ISO8601}, {This is a string which is the format that can be passed to $time.format and $time.parse to format and parse {@url https://en.wikipedia.org/wiki/ISO_8601, ISO8601} format. This format is the preferred format for exchanges of dates and times.},

    {time.time()}, {Returns the number of seconds since the Epoch as a floating point number.
    
    The Epoch may depend on your platform, but is most commonly 1970-01-01. You can check when the epoch is by passing `0` to $time.format:

```ks
>>> time.format(0.0)
'1970-01-01T00:00:00+0000'
```
},

    {time.clock()}, {Returns the number of seconds since the process started as a floating point number.},

    {time.sleep(dur)}, {Causes the current thread to sleep for `dur` seconds, which should be a floating point number
    
    The exact accuracy of this function cannot be guaranteed, it depends on the platform function. For example, if `nanosleep()` or `usleep()` are available in the C library, this function will be accurate. At worst, this function will only sleep to the nearest second},

    {time.now()}, {Returns a $time.DateTime referring to the current time, in UTC
    
    {@note See $time.localnow for local-equivalent function}},

    {time.localnow()}, {Returns a $time.DateTime referring to the current time, in the local timezone
    
    {@note See $time.now for UTC-equivalent function}},

    {time.format(val=none, fmt=time.ISO8601)}, {Returns a string which is the time value `val` (default: $time.now(), which may be a floating point number, or a $time.DateTime object) formatted according to `fmt`. 
    
    The format string is similar to $printf syntax, but with different seperators:
    {@dict
        {%%}, {Literal `%`},
        {%Y}, {The year, in full},
        {%y}, {The year, modulo 100 (i.e. `1970` would result in `70`)},
        {%m}, {The month of the year (starting at 1), zero-padded to 2 digits (i.e. February would be `02`)},
        {%B}, {The month of the year, in the current locale, full},
        {%b}, {The month of the year, in the current locale, abbreviated},
        {%U}, {The week of the year as a decimal number (Sunday is `0`). Days before the first Sunday are week 0},
        {%W}, {The week of the year as a decimal number (Monday is `0`). Days before the first Monday are week 0},
        {%j}, {The day of the year as a decimal number (starting with `001`), zero-padded to 3 digits},
        {%d}, {The day of the month as a decimal number (starting with `01`), zero-padded to 2 digits},
        {%A}, {The day of the week, in the current locale, full},
        {%a}, {The day of the week, in the current locale, abbreviated},
        {%w}, {The day of the week as an integer (Monday is `0`)},
        {%H}, {Hour (in 24-hour clock), zero-padded to 2 digits (`00`, ..., `23`)},
        {%I}, {Hour (in 12-hour clock), zero-padded to 2 digits (`00`, ..., `12`)},
        {%M}, {Minute, zero-padded to 2 digits (`00`, ..., `59`)},
        {%S}, {Second, zero-padded to 2 digits (`00`, ..., `59`)},
        {%f}, {Microsecond, zero-padded to 6 digits (`000000`, ..., `999999`)},
        {%z}, {Timezone UTC offset in `(+|-)HHMM[SS.[ffffff]]`},
        {%Z}, {Timezone name (or empty if there was none)},
        {%p}, {Current locale's equivalent of `AM` and `PM`},
        {%c}, {Current locale's default date/time representation},
        {%x}, {Current locale's default date representation},
        {%X}, {Current locale's default time representation},
    }
    },

    {time.DateTime(obj=none, tz=none)}, {
        This type represents a broken-down time structure comprised of the attributes humans commonly associate with a time. For example, the year, month, day, and so forth.

        DateTimes can be created with the empty constructor, `time.DateTime()`, which is equivalent to the $time.now function. Or, you can pass the first argument as a number of seconds since the Epoch (i.e. what is returned by $time.time). For example, `time.DateTime(0.0)` will give you a DateTime representing the system Epoch.

        The constructor also accepts another argument, `tz`, which is the timezone. If not given, or none, the resulting datetime is in UTC (which is to say, a reasonable default). To get a datetime in local time, you can pass `'local'` as the second argument. You can also give it a specific name of a timezone, and it will attempt to use that timezone.

        This type is not a completely consistent datatype (as it must deal with things like daylight savings, leap seconds, leap year, and so forth), so it is recommended to use a float to capture absolute times, and deal with timestamps.

        Here are some examples of creating datetimes in various ways (the output may differ based on your location, obviously!):

```ks
>>> time.DateTime()      # Current datetime, in UTC
<time.DateTime '2021-01-13T01:10:26+0000'>
>>> time.DateTime(0)     # Epoch, in UTC
<time.DateTime '1970-01-01T00:00:00+0000'>
>>> time.DateTime(0, "local") # Epoch, in current timezone
<time.DateTime '1969-12-31T19:00:00-0500'>
```

        {@dict
            {.tse}, {The time since Epoch, in number of seconds as a floating point number},
            {.tz}, {The timezone, which may be a string (the name), or `none` if there was no timezone},
            {.year}, {The year as an integer},
            {.month}, {The month as an integer},
            {.day}, {The day as an integer},
            {.hour}, {The hour as an integer},
            {.min}, {The minute as an integer},
            {.sec}, {The second as an integer},
            {.nano}, {The nanosecond as an integer},
        }
    },


}

@node m: Math, Math Module, {

This module, `m`, provides functionality to aid in mathematical problems/needs .This module contains common mathematical constants (such as {@math \pi}, {@math \tau}, {@math e}, and so forth), as well as functions that efficiently and accurately compute commonly used functions (such as {@math \sin}, {@math \cos}, {@math \Gamma}, and so forth). This module also includes some integer and number-theoretic functions, such as computing the greatest common denominator (GCD), binomial coefficients, and primality testing.

This module is meant to work with the types that follow the $number {@ref Patterns, pattern}, such as $int, $float, and $complex. Most functions are defined for real and complex evaluation. If a real number is given, then (generally) a real number is returned. If a complex number is given, then (generally) a complex number is returned. If a real number is given (for example, to $m.sqrt) and the result would be a complex number (i.e. `m.sqrt(-1)`), then an error is thrown (this makes it easy to find bugs, and in general real numbers are what most people care about – and they would like an error on code such as `m.sqrt(-1)`). To get around this, you can write: `m.sqrt(complex(-1))`, and the result will always be a complex, and an error won’t be thrown for negative numbers.

Constants are given in maximum precision possible within a float, but for all of these constants, their value is not exact. This causes some issues or unexpected results. For example, mathematically, {@math \sin(\pi) = 0}, but `m.sin(m.pi) == 1.22464679914735e-16`. This is expected when using finite precision. Just make sure to keep this in mind.

Here are some recommended ways to handle it:


```ks
>>> if m.sin(m.pi) == 0 {}               # Bad, may cause unexpected results
>>> if abs(m.sin(m.pi) - 0) < 1e-6 {}    # Better, uses a decent tolerance (1e-6 is pretty good)
>>> if m.isclose(m.sin(m.pi), 0) {}      # Best, use the m.isclose() function
```

@cdict
    {m.pi}, {
The value of {@url https://en.wikipedia.org/wiki/Pi, {@math \pi}}, as a $float

```ks
>>> m.pi
3.141592653589793
```

},
    {m.tau}, {
The value of {@url https://en.wikipedia.org/wiki/Turn_(angle)#Tau_proposals, {@math \tau}}, as a $float

```ks
>>> m.tau
6.283185307179586
```

},
    {m.e}, {
The value of {@url https://en.wikipedia.org/wiki/E_(mathematical_constant), {@math e}}, as a $float

```ks
>>> m.e
2.718281828459045
```

},
    {m.mascheroni}, {
The value of {@url https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant, {@math \gamma}}, as a $float

```ks
>>> m.mascheroni
0.577215664901533
```

},



}

}

}
